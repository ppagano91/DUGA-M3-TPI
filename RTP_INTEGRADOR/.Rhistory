plot(df_geodata, trend="1st")
pal <- colorRampPalette(c("lightblue","deepskyblue","blue","navy"))(100)
col_idx <- as.integer(cut(df$Precipitaciones, breaks = 100))
plot(df$Longitud, df$Latitud,
pch = 21, bg = pal[col_idx], col="black",
xlab = "Longitud", ylab = "Latitud", main = "Puntos y Precipitaciones",
asp = 1)
legend("topright", legend = c("Baja", "Media", "Alta"),
fill = c(pal[10], pal[50], pal[90]), bty="n")
# ---- Exploración de tendencias espaciales ----
par(mfrow = c(1,2))
# Scatter Longitud vs Precipitaciones
plot(df$Longitud, df$Precipitaciones,
pch = 10, col = "blue",
main = "Longitud vs Precipitaciones",
xlab = "Longitud", ylab = "Precipitación (mm/año)")
abline(lm(Precipitaciones ~ Longitud, data = df), col = "red", lwd = 2)
# Scatter Latitud vs Precipitaciones
plot(df$Latitud, df$Precipitaciones,
pch = 20, col = "darkgreen",
main = "Latitud vs Precipitaciones",
xlab = "Latitud", ylab = "Precipitación (mm/año)")
abline(lm(Precipitaciones ~ Latitud, data = df), col = "red", lwd = 2)
par(mfrow = c(1,1))
# Modelos lineales de tendencia
m_lon <- lm(Precipitaciones ~ Longitud, data = df)
m_lat <- lm(Precipitaciones ~ Latitud, data = df)
summary(m_lon)
summary(m_lat)
# ---- Superficie de tendencia (modelo espacial global) ----
# Ajuste polinómico 1er orden: Precip = a + bX + cY
m_trend <- lm(Precipitaciones ~ Longitud + Latitud, data = df)
summary(m_trend)
lon_seq <- seq(min(df$Longitud), max(df$Longitud), length.out = 100)
lat_seq <- seq(min(df$Latitud), max(df$Latitud), length.out = 100)
grid <- expand.grid(Longitud = lon_seq, Latitud = lat_seq)
grid$pred <- predict(m_trend, newdata = grid)
# Mapa de la superficie de tendencia
z <- matrix(grid$pred, nrow = 100, ncol = 100)
filled.contour(lon_seq, lat_seq, z,
color.palette = colorRampPalette(brewer.pal(9, "YlGnBu")),
xlab = "Longitud", ylab = "Latitud",
main = "Superficie de tendencia (modelo lineal)",
plot.axes = {
axis(1); axis(2)
points(df$Longitud, df$Latitud, pch = 20, col = "black")
},
asp = 1)
filled.contour(lon_seq, lat_seq, z,
color.palette = colorRampPalette(brewer.pal(9, "YlGnBu")),
xlab = "Longitud", ylab = "Latitud",
main = "Superficie de tendencia (modelo lineal)",
plot.axes = {
axis(1); axis(2)
points(df$Longitud, df$Latitud, pch = 20, col = "black")
text(df$Longitud, df$Latitud,
labels = round(df$Precipitaciones,0), cex=0.7, pos=3)
},
asp = 1)
# La superficie de tendencia de primer orden evidencia un gradiente espacial en sentido oeste–este, con valores crecientes de precipitación hacia el este. Este patrón sugiere la presencia de una tendencia lineal global, de intensidad moderada, que deberá considerarse al momento de ajustar el modelo geoestadístico.
plot_ly(df, x = ~Longitud, y = ~Latitud, z = ~Precipitaciones,
type = "scatter3d", mode = "markers",
marker = list(size = 4, color = "blue")) %>%
add_surface(x = lon_seq, y = lat_seq, z = matrix(grid$pred, 100, 100),
colorscale = "Blues", opacity = 0.5) %>%
layout(scene = list(
xaxis = list(title = "Longitud"),
yaxis = list(title = "Latitud"),
zaxis = list(title = "Precipitaciones")
))
# ---- Análisis de normalidad ----
# Tests estadísticos
shapiro <- shapiro.test(df$Precipitaciones)  # Shapiro-Wilk
cat("Shapiro-Wilk original W =", round(shapiro$statistic,3),
"p =", signif(shapiro$p.value,3), "\n")
cat("Asimetría ", skewness(df$Precipitaciones), "\n")   # asimetría
cat("Kurtosis ", kurtosis(df$Precipitaciones), "\n")   # curtosis
# Posibles Transformaciones
df$prec_log  <- ifelse(df$Precipitaciones > 0, log(df$Precipitaciones), NA)
df$prec_sqrt <- sqrt(df$Precipitaciones)
bc_trans <- powerTransform(df$Precipitaciones)
summary(bc_trans)
df$prec_bc <- bcPower(df$Precipitaciones, coef(bc_trans))
sh_log  <- shapiro.test(na.omit(df$prec_log))
sh_sqrt <- shapiro.test(df$prec_sqrt)
cat("Shapiro log  p =", signif(sh_log$p.value,3), "\n")
cat("Shapiro sqrt p =", signif(sh_sqrt$p.value,3), "\n")
# ---- Histogramas ----
par(mfrow=c(1,3))
hist(df$Precipitaciones, prob = TRUE,
main = "Histograma Ppts con curva normal",
ylab = "Frecuencia",
xlab = "Precipitación (mm/año)",
col = "lightblue",
border = "white")
lines(density(df$Precipitaciones, na.rm = TRUE),
col = "red", lwd = 2)
hist(df$prec_log, prob = TRUE,
main = "Histograma Ppts Log con curva normal",
ylab = "Frecuencia",
xlab = "Precipitación log (mm/año)",
col = "lightblue",
border = "white")
lines(density(df$prec_log, na.rm = TRUE),
col = "red", lwd = 2)
hist(df$prec_sqrt, prob = TRUE,
main = "Histograma PPts Sqrt con curva normal",
ylab = "Frecuencia",
xlab = "Precipitación sqrt (mm/año)",
col = "lightblue",
border = "white")
lines(density(df$prec_sqrt, na.rm = TRUE),
col = "red", lwd = 2)
# ---- QQ-plots ----
par(mfrow=c(1,3))
qqnorm(df$Precipitaciones, main="QQ-Plot Original")
qqline(df$Precipitaciones, col="red")
qqnorm(df$prec_log, main="QQ-Plot Log", ylab="log(precipitaciones)")
qqline(df$prec_log, col="red")
qqnorm(df$prec_sqrt, main="QQ-Plot Sqrt", ylab="sqrt(precipitaciones)")
qqline(df$prec_sqrt, col="red")
par(mfrow=c(1,1))
par(mfrow=c(1,2))
hist(df$Precipitaciones, prob = TRUE,
main = "Histograma Precipitaciones",
ylab = "Frecuencia",
xlab = "Precipitación (mm/año)",
col = "lightblue",
border = "white")
lines(density(df$Precipitaciones, na.rm = TRUE),
col = "red", lwd = 2)
qqnorm(df$Precipitaciones, main="QQ-Plot Precipitaciones")
qqline(df$Precipitaciones, col="red")
shapiro <- shapiro.test(df$prec_log)  # Shapiro-Wilk
cat("Shapiro-Wilk Log W =", round(shapiro$statistic,3),
"p =", signif(shapiro$p.value,3), "\n")
cat("Asimetría ", skewness(df$prec_log), "\n")
cat("Kurtosis ", kurtosis(df$prec_log), "\n")
shapiro <- shapiro.test(df$prec_sqrt)  # Shapiro-Wilk
cat("Shapiro-Wilk SQRT W =", round(shapiro$statistic,3),
"p =", signif(shapiro$p.value,3), "\n")
cat("Asimetría ", skewness(df$prec_sqrt), "\n")
cat("Kurtosis ", kurtosis(df$prec_sqrt), "\n")
shapiro <- shapiro.test(df$prec_bc)  # Shapiro-Wilk
cat("Shapiro-Wilk BCPower W =", round(shapiro$statistic,3),
"p =", signif(shapiro$p.value,3), "\n")
cat("Asimetría ", skewness(df$prec_bc), "\n")
cat("Kurtosis ", kurtosis(df$prec_bc), "\n")
get_results <- function(x, nombre){
x <- na.omit(x)
sh <- shapiro.test(x)
data.frame(
Transformacion = nombre,
W = round(sh$statistic, 3),
p_value = signif(sh$p.value, 3),
Asimetria = round(skewness(x), 3),
Curtosis = round(kurtosis(x), 3)
)
}
tabla_resumen <- rbind(
get_results(df$Precipitaciones, "Original"),
get_results(df$prec_log, "Log"),
get_results(df$prec_sqrt, "Sqrt"),
get_results(df$prec_bc, "Box-Cox")
)
print(tabla_resumen)
# ---- ANÁLISIS GEOESTADÍSTICO ----
# Requisitos: geoR, gstat, sp, sf, raster
# 1) Preparar Datos
m_trend <- lm(Precipitaciones ~ Longitud + Latitud, data = df)
df$resid_trend <- residuals(m_trend)
data_for_geo <- df
data_for_geo$zvar <- df$Precipitaciones
# 2) Crear objeto geoR
geod <- as.geodata(data_for_geo,
coords.col = c("Longitud","Latitud"),
data.col = "Precipitaciones")
# 3) Ver duplicados
dup.coords(geod)
# 4) Variogramas experimentales
# Opción 1 con variog
par(mfrow=c(1,1))
vario_exp_variog_1 <- variog(geod)
plot(vario_exp_variog_1,
main = "Variograma Experimental de Precipitaciones", # título
xlab = "Distancia",                                  # etiqueta eje X
ylab = "Semivarianza",                               # etiqueta eje Y
pch = 19,                                            # estilo de punto
col = "skyblue",                                    # color de puntos
cex = 1.2,                                           # tamaño de puntos
lwd = 2,                                             # grosor de líneas
col.main = "black",                                  # color del título
col.lab = "black",                                   # color de etiquetas de ejes
col.axis = "gray40",                                 # color de números de ejes
cex.main = 1.5,                                      # tamaño del título
cex.lab = 1.3,                                       # tamaño etiquetas de ejes
cex.axis = 1.1                                       # tamaño números ejes
)
# Agregar rejilla para mejorar lectura
grid(col = "lightgray", lty = "dotted")
# Agregar línea de tendencia (opcional, usando loess)
lines(lowess(vario_exp_variog_1$u, vario_exp_variog_1$v),
col = "grey", lwd = 2, lty = 2)
# Opción 2 con variog
maxd <- max(dist(geod$coords)) / 2
uvec <- seq(0, maxd, length.out = 12)
vario_exp_variog_2 <- variog(geod, uvec = uvec, tol.hor = uvec[2]/2)
df_sp <- df
coordinates(df_sp) <- ~ Longitud + Latitud
par(mfrow=c(1,2))
plot(vario_exp_variog_2,
main = "Variograma experimental de Ppts (con uvec y tol.hor)",
xlab = "Distancia",
ylab = "Semivarianza")
plot(vario_exp_variog_1, main="Varigorama: valores de Ppts")
max_dist <- max(spDists(df_sp, longlat = TRUE))
# Opción 3 con variogram
variograma_exp_variogram_3 <- variogram(Precipitaciones ~ 1, df_sp, cutoff = max_dist/2, width = 0.2)
plot(variograma_exp_variogram_3, lwd = 2)
# Opción 4 con variogram
variograma_exp_variogram_4 <- variogram(Precipitaciones ~ 1, df_sp)
plot(variograma_exp_variogram_4, lwd = 2)
par(mfrow=c(1,2))
p1 <- plot(variograma_exp_variogram_3, main="Variograma con Cutoff + Width")
p2 <- plot(variograma_exp_variogram_4, main="Variograma por Default")
grid.arrange(p1, p2, ncol=2)
# windows()
# eyefit(vario_exp)
# dev.off()
# 5) Ajuste de modelos teóricos con likfit (ML y REML)
# Opcion 1: Max Distance=2.33 Sill= 103574  Range=1.26  Nugget=14286
# Opcion 2: Max Distance=2.33 Sill= 11786  Range=1.13  Nugget=3571
# Opcion 3: Max Distance=¿? Sill= 140966  Range=3.939  Nugget=853
# Varianza empírica de la variable
emp_var <- var(geod$data, na.rm = TRUE)
# Parámetros iniciales (heurística)
ini_cov_pars <- c(emp_var * 0.6, 0.25 * max(dist(geod$coords)))
# Ajustar modelos con ML y REML
models <- c("sph", "exp", "gau")
fits <- list()
for(mod in models){
fits[[mod]] <- list()
fits[[mod]]$ml <- tryCatch(
likfit(geod, cov.model = mod,
ini.cov.pars = ini_cov_pars,
nugget = emp_var*0.05,
lik.method = "ML"),
error = function(e) NULL
)
fits[[mod]]$reml <- tryCatch(
likfit(geod, cov.model = mod,
ini.cov.pars = ini_cov_pars,
nugget = emp_var*0.05,
lik.method = "REML"),
error = function(e) NULL
)
}
# 6) Mostrar resultados resumidos y comparar AIC
aic_tab <- data.frame(model=character(),
method=character(),
AIC=numeric(),
stringsAsFactors=FALSE)
for(mod in names(fits)){
if(!is.null(fits[[mod]]$ml)){
aic_tab <- rbind(aic_tab, data.frame(model=mod, method="ML", AIC=fits[[mod]]$ml$AIC))
}
if(!is.null(fits[[mod]]$reml)){
aic_tab <- rbind(aic_tab, data.frame(model=mod, method="REML", AIC=fits[[mod]]$reml$AIC))
}
}
print(aic_tab)
# Seleccionar mejor ajuste
best_row <- aic_tab[which.min(aic_tab$AIC), ]
cat("Mejor ajuste por AIC:", best_row$model, "-", best_row$method, "\n")
best_fit <- fits[[best_row$model]][[tolower(best_row$method)]]
# 8) Interpretación directa de parámetros (ejemplo)
# Variograma experimental con ajustes
par(mfrow=c(1,1))
plot(vario_exp_variog_1,
main = "Variograma experimental con ajustes",
xlab = "Distancia (km)",     # O "Distancia (°)" si no convertiste coords
ylab = "Semivarianza γ(h)",
pch = 19,                    # puntos sólidos
col = "black",
cex = 1.2,                   # tamaño puntos
cex.lab = 1.2,               # etiquetas ejes más grandes
cex.main = 1.3,              # título más grande
cex.axis = 1.1,              # valores de los ejes más grandes
las = 1,                     # ejes horizontales
xlim = c(0, max(vario_exp_variog_1$u)*1.1),  # margen extra en eje x
ylim = c(0, max(vario_exp_variog_1$v)*1.1)   # margen extra en eje y
)
# Colores personalizados para modelos
cols <- c("red", "blue", "forestgreen", "purple")
ltys <- c(1, 1, 1, 1)   # distintos estilos de línea
lwds <- c(2, 2, 2, 2)
i <- 1
for(mod in names(fits)){
if(!is.null(fits[[mod]]$reml)){
lines(fits[[mod]]$reml,
col = cols[i],
lwd = lwds[i],
lty = ltys[i])
i <- i + 1
}
}
# Leyenda con fondo transparente
legend("bottomright",
legend = names(fits),
col = cols[1:(i-1)],
lty = ltys[1:(i-1)],
lwd = lwds[1:(i-1)],
bty = "n",                 # sin borde
cex = 1.1,                 # tamaño texto
title = "Modelos")
if(!is.null(best_fit)){
sigma2 <- best_fit$cov.pars[1]   # varianza estructurada (partial sill)
phi <- best_fit$cov.pars[2]      # rango (distance a la que desaparece la autocorrelación)
nug <- best_fit$nugget           # efecto pepita
cat(sprintf("Modelo seleccionado: %s (%s)\n",
as.character(best_row$model), best_row$method))
cat(sprintf("Parámetros:\n - Nugget (pepita): %.3f\n - Partial sill (σ²): %.3f\n - Range (φ): %.3f\n",
nug, sigma2, phi))
cat(sprintf("Meseta total (sill) = Nugget + σ² = %.3f\n", nug + sigma2))
}
selected_variogram <- likfit(geod, cov.model = "spherical", ini.cov.pars = c(140966.260, 3.939), lik.method = "REML", nugget = 852.697)
pred_grid <- expand.grid(x = seq(min(geod$coords[,1]),
max(geod$coords[,1]), l= 100),
y = seq(min(geod$coords[,2]),
max(geod$coords[,2]), l= 100)
)
plot(geod$coords, pch = 20, asp = 1)
points(pred_grid, pch = "+", cex = 0.2, col="green")
ko_reml <- krige.conv(geod, locations = pred_grid, krige = krige.control(obj.model = selected_variogram))
summary(ko_reml)
df_sp <- df
coordinates(df_sp) <- ~ Longitud + Latitud
ko_reml_sp <- SpatialPixelsDataFrame(points=pred_grid, data = data.frame(ko_reml[1:2]))
spplot(ko_reml_sp, zcol="predict", col.regions=colorRampPalette(brewer.pal(9, "Blues"))(100), main="Predicciones de Precipitaciones", xlab="Longitud", ylab="Latitud")
spplot(ko_reml_sp, zcol="predict", col.regions=colorRampPalette(brewer.pal(9, "Blues"))(100), contour=TRUE, main="Predicciones de Precipitaciones", xlab="Longitud", ylab="Latitud")
spplot(ko_reml_sp, zcol="predict",
sp.layout = list("sp.points", df_sp, col="black", pch=20),
col.regions=colorRampPalette(brewer.pal(9, "Blues"))(100),
contour=TRUE,
main="Predicciones de Precipitaciones",
xlab="Longitud", ylab="Latitud")
sp.layout.list <- list(
list("sp.points", df_sp, col="black", pch=20, cex=1),
list("sp.text",
coordinates(df_sp),
txt = round(df_sp$Precipitaciones, 0),
cex = 0.75, font = 2, col="black")
)
spplot(ko_reml_sp, zcol="predict",
sp.layout = sp.layout.list,
col.regions=colorRampPalette(brewer.pal(9, "Blues"))(100),
contour = TRUE,
main = "Predicciones de Precipitaciones (mm/año)",
xlab = "Longitud", ylab = "Latitud")
pred_grid <- expand.grid(
x = seq(min(geod$coords[,1]), max(geod$coords[,1]), l = 300),
y = seq(min(geod$coords[,2]), max(geod$coords[,2]), l = 300)
)
ko_reml <- krige.conv(geod, locations = pred_grid, krige = krige.control(obj.model = selected_variogram))
df_sp <- df
coordinates(df_sp) <- ~ Longitud + Latitud
ko_reml_sp <- SpatialPixelsDataFrame(points=pred_grid, data = data.frame(ko_reml[1:2]))
spplot(
ko_reml_sp,
zcol = "predict",
col.regions = colorRampPalette(brewer.pal(9, "Blues"))(100),
contour = TRUE,
main = "Mapa Kriging de Precipitaciones en el NOA (mm/año)",
xlab = "Longitud (°O)",
ylab = "Latitud (°S)",
scales = list(draw = TRUE, tck = c(1,1)),   # ticks hacia adentro
sp.layout = list(
list("sp.points", df_sp, col = "black", pch = 20, cex = 1.2),
list("sp.text", coordinates(df_sp),
txt = round(df_sp$Precipitaciones, 1),
pos = 1, cex = 0.75, col = "black"),
list("sp.text", coordinates(df_sp),
txt = df_sp$Localidad,
pos = 3, cex = 0.75, col = "black", font = 3),
list("SpatialPolygonsRescale", layout.scale.bar(),
offset = c(-66, -26), scale = 1)
)
)
help(spplot)
pred_values <- ko_reml$predict
# Resumen estadístico básico
summary(pred_values)
# Opcional: medidas adicionales
mean(pred_values, na.rm=TRUE)
sd(pred_values, na.rm=TRUE)
range(pred_values, na.rm=TRUE)
quantile(pred_values, probs=c(0.25, 0.5, 0.75), na.rm=TRUE)
spplot(ko_reml_var_sp, zcol="ko_reml.krige.var",
sp.layout = list("sp.points", suelo_sp, col="black", pch=20),
col.regions=rev(heat.colors(100)),
contour=FALSE,
main="Superficie de varianzas y puntos de muestreo (Precipitaciones)",
xlab="Longitud", ylab="Latitud",
key.space = "right",
scales = list(x = list(at = x_ticks),
y = list(at = y_ticks)
)
)
ko_reml_var_sp <- SpatialPixelsDataFrame(points = pred_grid, data = data.frame(ko_reml$krige.var))
spplot(ko_reml_var_sp, zcol="ko_reml.krige.var",
sp.layout = list("sp.points", suelo_sp, col="black", pch=20),
col.regions=rev(heat.colors(100)),
contour=FALSE,
main="Superficie de varianzas y puntos de muestreo (Precipitaciones)",
xlab="Longitud", ylab="Latitud",
key.space = "right",
scales = list(x = list(at = x_ticks),
y = list(at = y_ticks)
)
)
x_ticks <- round(seq(min(geod$coords[,1]), max(geod$coords[,1]), by = 0.5), digits = 2)
y_ticks <- round(seq(min(geod$coords[,2]), max(geod$coords[,2]), by = 0.5), digits = 2)
ko_reml_var_sp <- SpatialPixelsDataFrame(points = pred_grid, data = data.frame(ko_reml$krige.var))
spplot(ko_reml_var_sp, zcol="ko_reml.krige.var",
sp.layout = list("sp.points", suelo_sp, col="black", pch=20),
col.regions=rev(heat.colors(100)),
contour=FALSE,
main="Superficie de varianzas y puntos de muestreo (Precipitaciones)",
xlab="Longitud", ylab="Latitud",
key.space = "right",
scales = list(x = list(at = x_ticks),
y = list(at = y_ticks)
)
)
x_ticks <- round(seq(min(geod$coords[,1]), max(geod$coords[,1]), by = 0.5), digits = 2)
y_ticks <- round(seq(min(geod$coords[,2]), max(geod$coords[,2]), by = 0.5), digits = 2)
ko_reml_var_sp <- SpatialPixelsDataFrame(points = pred_grid, data = data.frame(ko_reml$krige.var))
spplot(ko_reml_var_sp, zcol="ko_reml.krige.var",
sp.layout = list("sp.points", df_sp, col="black", pch=20),
col.regions=rev(heat.colors(100)),
contour=FALSE,
main="Superficie de varianzas y puntos de muestreo (Precipitaciones)",
xlab="Longitud", ylab="Latitud",
key.space = "right",
scales = list(x = list(at = x_ticks),
y = list(at = y_ticks)
)
)
x_ticks <- round(seq(min(geod$coords[,1]), max(geod$coords[,1]), by = 0.5), digits = 2)
y_ticks <- round(seq(min(geod$coords[,2]), max(geod$coords[,2]), by = 0.5), digits = 2)
ko_reml_var_sp <- SpatialPixelsDataFrame(points = pred_grid, data = data.frame(ko_reml$krige.var))
spplot(ko_reml_var_sp, zcol="ko_reml.krige.var",
sp.layout = list("sp.points", df_sp, col="black", pch=20),
col.regions = colorRampPalette(brewer.pal(9, "Blues"))(100),
contour=FALSE,
main="Superficie de varianzas y puntos de muestreo (Precipitaciones)",
xlab="Longitud", ylab="Latitud",
key.space = "right",
scales = list(x = list(at = x_ticks),
y = list(at = y_ticks)
)
)
min_lon <- min(pred_grilla$x, na.rm = TRUE)
library(sf)
# bounding box del área de predicción
min_lon <- min(pred_grilla$x, na.rm = TRUE)
library(sf)
# bounding box del área de predicción
min_lon <- min(pred_grid$x, na.rm = TRUE)
max_lon <- max(pred_grid$x, na.rm = TRUE)
min_lat <- min(pred_grid$y, na.rm = TRUE)
max_lat <- max(pred_grid$y, na.rm = TRUE)
bbox_coords <- matrix(
c(min_lon, min_lat,
max_lon, min_lat,
max_lon, max_lat,
min_lon, max_lat,
min_lon, min_lat),
ncol = 2,
byrow = TRUE
)
bbox_polygon <- st_sfc(st_polygon(list(bbox_coords)), crs = 4326)
bbox_sf <- st_sf(geometry = bbox_polygon)
st_write(bbox_sf, "area_prediccion.shp", driver = "ESRI Shapefile", append = FALSE)
cat("✅ area_prediccion.shp exportado\n")
# convertir a sf
puntos_muestreo_sf <- st_as_sf(df, coords = c("Longitud", "Latitud"), crs = 4326)
st_write(puntos_muestreo_sf, "puntos_muestreo.shp", driver = "ESRI Shapefile", append = FALSE)
cat("✅ puntos_muestreo.shp exportado\n")
x_unique <- unique(pred_grid$x)
y_unique <- unique(pred_grid$y)
z_matrix <- matrix(ko_reml$predict, nrow = length(x_unique), ncol = length(y_unique))
contour_lines <- contourLines(x = x_unique, y = y_unique, z = z_matrix)
lines_sf_list <- lapply(seq_along(contour_lines), function(i) {
st_linestring(cbind(contour_lines[[i]]$x, contour_lines[[i]]$y))
})
contours_sf <- st_sf(
level = sapply(contour_lines, function(cl) cl$level),
geometry = st_sfc(lines_sf_list, crs = 4326)
)
st_write(contours_sf, "isoprecipitaciones.shp", driver = "ESRI Shapefile", append = FALSE)
cat("✅ isoprecipitaciones.shp exportado\n")
raster_predicciones_sp <- raster(ko_reml_sp)
crs(raster_predicciones_sp) <-CRS("+init=epsg:4326")
writeRaster(raster_predicciones_sp, "predicciones_ppts.tif", format="GTiff", overwrite=TRUE)
cat("✅ predicciones_ppts.tif")
raster_varianzas_sp <- raster(ko_reml_var_sp)
crs(raster_varianzas_sp) <-CRS("+init=epsg:4326")
writeRaster(raster_varianzas_sp, "varianzas_ppts.tif", format="GTiff", overwrite=TRUE)
cat("✅ predicciones_ppts.tif )
(.packages())
writeLines(.packages(), "paquetes_cargados.txt")
